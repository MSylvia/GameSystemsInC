TileMap_whole.txt
Earlier this year
8 Apr

You uploaded an item
Text
TileMap_whole.txt
#pragma once

#include "raylib.h"
#include "TileSet.h"

class TileMap{
    public:
        TileMap(TileSet& newTileSet, Vector2 mapPosition, int Columns, int Rows);
        ~TileMap();
        void SetMapSize(int Columns, int Rows);
        void SetPosition(Vector2 _position);
        int GetTileId(Vector2 CellPosition);
        int GetTileIdWorld(Vector2 WorldPosition);
        Vector2 World2Tile(Vector2 _position);
        Vector2 Tile2World(Vector2 _position);
        void Draw();
    private:
        int* tilemap;
        TileSet* tileset;
        RenderTexture2D texture;
        Vector2 position;
        int posX;
        int posY;
        int width;
        int height;
        Vector2 cell_size;
        bool update;                //Flag for render texture update
        void Update();              //Render texture update
        void DrawMapTiled();
};

TileMap::TileMap(TileSet& newTileSet, Vector2 mapPosition, int Columns, int Rows){
    tileset = &newTileSet;
    cell_size = tileset->tile_size;
    position = mapPosition;
    posX = int(position.x);     //static_cast<int>
    posY = int(position.y);
    width = Columns;
    height = Rows;
    tilemap = new int[width * height]{-1};
    update = false;
    texture = LoadRenderTexture(float(width)*cell_size.x, float(height)*cell_size.y);
    
    //test fill map
    for(int i=0; i<width*height; i++){
        tilemap[i] = i;
    }
}

TileMap::~TileMap(){
    delete [] tilemap;
    UnloadRenderTexture(texture);
}

void TileMap::SetMapSize(int left = 0, int top=0, int right=0, int bottom=0){
    position.x += float(left);
    position.y += float(top);
    posX += left;
    posY += top;
    int w = width -left +right;
    int h = height -top +bottom;
    
    int* tmp = tilemap;                                         //preparing for deleting old pointer
    tilemap = new int[w * h]{-1};
    
    //move old map to new
    for (y = 0; y < width; ++y){
        for (x = 0; x< height; ++x){
            if (x+left >= 0 && y+top >= 0 && x+left < w && y+top < h){
                newMap[width*(y+top) + x+left] = tmp[width*y + x]
            }
        }
    }
    width = w;
    height = h;
    delete [] tmp;                                              //remove old pointer
    UnloadRenderTexture(RenderTexture2D texture);
    texture = LoadRenderTexture(float(width)*cell_size.x, float(height)*cell_size.y);
    update = true;                                              //set flag for render texture update
}

int TileMap::GetTileId(Vector2 CellPosition){
    bool lessX = CellPosition.x < 0.0f;
    bool lessY = CellPosition.y < 0.0f;
    bool biggerX = CellPosition.x > float(width);
    bool biggerY = CellPosition.y > float(height);
    if (lessX || lessY || biggerX || biggerY){
        return -1;
    }
    return tilemap[width*CellPosition.y + CellPosition.x];
}

int TileMap::GetTileIdWorld(Vector2 WorldPosition){
    bool lessX = WorldPosition.x < position.x;
    bool lessY = WorldPosition.y < position.y;
    bool biggerX = WorldPosition.x > position.x + cell_size.x * float(width);
    bool biggerY = WorldPosition.y > position.y + cell_size.y * float(height);
    if (lessX || lessY || biggerX || biggerY){
        return -1;
    }
    int x = int(WorldPosition.x - position.x)/width;
    int y = int(WorldPosition.y - position.y)/height;
    return tilemap[width*y + x];
}

Vector2 TileMap::SetPosition(Vector2 _position){
    position = _position;
    posX = int(position.x); //static_cast<int> 
    posY = int(position.y);
}

Vector2 TileMap::World2Tile(Vector2 _position){
    float _x = floor((_position.x - position.x)/tile_size.x) * tile_size.x;
    float _y = floor((_position.y - position.y)/tile_size.y) * tile_size.y;
    return Vector2{_x, _y};
}

Vector2 TileMap::Tile2World(Vector2 _position){
    float _x = _position.x * tile_size.x + position.x;
    float _y = _position.y * tile_size.y + position.y;
    return Vector2{_x, _y};
}

void TileMap::Draw(){
    Update();
    //DrawTextureV(texture.texture, position, WHITE);
    DrawTextureRec(texture.texture, (Rectangle){ 0, 0, texture.texture.width, texture.texture.height }, (Vector2){ 0, 0 }, WHITE);
    //DrawTextureRec(texture.texture, (Rectangle){ 0, 0, texture.texture.width, -texture.texture.height }, (Vector2){ 0, 0 }, WHITE);
}

void TileMap::Update(){
    if (!update){
        return;
    }
    void BeginTextureMode(texture);           // Initializes render texture for drawing
        DrawMapTiled()
    void EndTextureMode(void);
    update = false;
}

void TileMap::DrawMapTiled(){
    for(int y=0; y<height; y++){
        for(int x=0; x<width; x++){
            tileset->draw_tile(tilemap[width*y + x], {x*cell_size.x, y*cell_size.y});
        }
    }
}

void TileMap::DrawMapPart(Vector2 _pos, Vector2  _size){
    Vector2 tileSize = World2Tile(_size) + tile_size;
    Vector2 drawPosition = _pos - ceil(position/tile_size) * tile_size; //Rendering position against RenderTexture
    
    //Need first drawable tile
    int firstColumn = floor(drawPosition.x/tile_size.x)*tile_size.x;
    int firstRow    = floor(drawPosition.y/tile_size.y)*tile_size.y;
    
    DrawTextureV(RenderTexture.texture, -(position % tile_size)); //Draw RenderTexture
}










